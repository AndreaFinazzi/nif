//  Copyright (c) 2021 Unmanned System Research Group @ KAIST
//  Author:

//
// Created by usrg on 6/23/21.
//

#ifndef ROS2MASTER_CONTROL_SAFETY_LAYER_NODE_H
#define ROS2MASTER_CONTROL_SAFETY_LAYER_NODE_H

#include <nav_msgs/msg/odometry.hpp>
#include <queue>

#include "nif_common/types.h"
#include "nif_common/constants.h"
#include "nif_common_nodes/i_base_synchronized_node.h"

//#include "../../../../nif_common/nif_common/include/nif_common/types.h"
#include "rclcpp/rclcpp.hpp"

namespace nif
{
    namespace control
    {

        /**
 * ControlSafetyLayerNode is responsible to send the final control message to
 * the car. It stores the control commands generated by one or more controllers,
 * and it submits the [best] available control to the vehicle interface. Being
 * subclass of IBaseSynchronizedNode, its run() function is called with a fixed
 * frequency.
 *
 * Its inputl is of type ControlCommand, which contains the set of controls that
 * the car interface can accept, but as an output each control value is also
 * sent separately.
 *
 */
        class ControlSafetyLayerNode : public nif::common::IBaseSynchronizedNode
        {
        public:
            /**
   * Initialize ControlSafetyNodeLayer with default period (defined by
   * IBaseSynchronizedNode)
   * @param node_name
   * @param options
   */
            ControlSafetyLayerNode(const std::string &node_name,
                                   const rclcpp::NodeOptions &options)
                                   : ControlSafetyLayerNode(node_name, options, nif::common::constants::SYNC_PERIOD_DEFAULT) {

                                   }

            /**
   * Initialize ControlSafetyNodeLayer with custom period.
   * @param node_name
   * @param options
   * @param period Custom synchronization period. It's passed to
   * IBaseSynchronizedNode and determines the frequency run() is called at.
   */
            template <class DurationRepT, class DurationT>
            ControlSafetyLayerNode(
                const std::string &node_name,
                const rclcpp::NodeOptions &options,
                const std::chrono::duration<DurationRepT, DurationT> period)
                : IBaseSynchronizedNode(node_name, options, period)
            {
                this->control_pub = this->create_publisher<nif::common::msgs::ControlCmd>(
                    "/control_safety_layer/control_cmd", rclcpp::QoS{1});

                this->steering_control_pub =
                    this->create_publisher<nif::common::msgs::ControlSteeringCmd>(
                        "/control_safety_layer/steering_control_cmd", rclcpp::QoS{1});

                this->accelerator_control_pub =
                    this->create_publisher<nif::common::msgs::ControlAcceleratorCmd>(
                        "/control_safety_layer/accelerator_control_cmd", rclcpp::QoS{1});

                this->braking_control_pub =
                    this->create_publisher<nif::common::msgs::ControlBrakingCmd>(
                        "/control_safety_layer/braking_control_cmd", rclcpp::QoS{1});

                this->gear_control_pub =
                    this->create_publisher<nif::common::msgs::ControlGearCmd>(
                        "/control_safety_layer/gear_control_cmd", rclcpp::QoS{1});
            }

        protected:
        private:
            // Prevent default constructor to be called from the outside
            ControlSafetyLayerNode();

            void initParameters();
            void getParameters();

            /**
   * Stores control commands coming from the controllers' stack. It's flushed at
   * every iteration by run(), that is it must store only the controls relative
   * to a time quantum.
   */
            std::priority_queue<nif::common::msgs::ControlCmd::SharedPtr> control_buffer;

            /**
   * Subscriber to the topic of control commands. Each incoming command is then
   * saved in the buffer (should check the age).
   */
            rclcpp::Subscription<nif::common::msgs::ControlCmd>::SharedPtr control_sub;

            /**
   * Control publisher. Publishes the effective command to the vehicle interface
   * topic.
   */
            rclcpp::Publisher<nif::common::msgs::ControlCmd>::SharedPtr control_pub;

            /**
   * Steering Control publisher. Publishes the effective command to the vehicle interface
   * topic.
   */
            rclcpp::Publisher<nif::common::msgs::ControlSteeringCmd>::SharedPtr
                steering_control_pub;

            /**
   * Accelerator Control publisher. Publishes the effective command to the vehicle interface
   * topic.
   */
            rclcpp::Publisher<nif::common::msgs::ControlAcceleratorCmd>::SharedPtr
                accelerator_control_pub;

            /**
   * Braking Control publisher. Publishes the effective command to the vehicle interface
   * topic.
   */
            rclcpp::Publisher<nif::common::msgs::ControlBrakingCmd>::SharedPtr
                braking_control_pub;

            /**
   * Gear Control publisher. Publishes the effective command to the vehicle interface
   * topic.
   */
            rclcpp::Publisher<nif::common::msgs::ControlGearCmd>::SharedPtr
                gear_control_pub;

            void controlCallback(const nif::common::msgs::ControlCmd::SharedPtr &msg);

            void run() override;

            bool publishSteeringCmd(const nif::common::msgs::ControlSteeringCmd &msg);
            bool publishAcceleratorCmd(const nif::common::msgs::ControlAcceleratorCmd &msg);
            bool publishBrakingCmd(const nif::common::msgs::ControlBrakingCmd &msg);
            bool publishGearCmd(const nif::common::msgs::ControlGearCmd &msg);

            //  TODO define safety checks functions
        };
    } // namespace control
} // namespace nif

#endif // ROS2MASTER_CONTROL_SAFETY_LAYER_NODE_H
